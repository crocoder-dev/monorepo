import blogHeader from "../../content/images/blogs/edge-drizzle-vercel/hero.png?preset=responsive";
import BlogLayout from "../../Layouts/BlogLayout";

export const meta = {
  id: "edge",
  title: "EDGE",
  description:
    "",
  category: "",
  image: blogHeader,
  date: 1680525775308,
  updatedAt: 1680525775308,
  author: "davidabram",
  editor: "velimirujevic",
  abstract:
    "",
  pageType: "blog-posting"
};

## Serverless and Edge functions

Serverless functions has changed the way we build web applications. You don't have to worry about managing servers or infrastructure, you can focus on writing code and adding new features to their applications.

You write the code of the function, deploy it and the cloud provider exposes the functions endpoint, manages and automatically scales the resources based on the incoming requests.

Sounds great, until you hit the dreaded [cold start](https://mikhail.io/serverless/coldstarts/aws/).

Most of the cold starts add about 50 to 500ms overhead, but there are cases where cold starts can get up to 2 to 3 sec. For example, hitting cold start while connecting to a db via prisma ORM in a node.js serverless function [took over 2.5 seconds](https://github.com/prisma/prisma/issues/10724). [Prisma team have solved the issue](https://www.prisma.io/blog/prisma-and-serverless-73hbgKnZ6t) while I was writing the article, so better bump your Prisma verison.

Not so long ago Edge functions were presented; a serverless function that run at the Edge. Edge functions differ a bit from serverless functions, usually they run on a restricted, sandboxed runtime, physically closer to the user and without any cold start.

So before we start moving your serverless functions to the edge, let's take a deeper look at the downsides of edge functions.

## Global Edge functions




Edge functions are serverless functions run at the Edge.

https://www.cloudping.co/grid

https://tools.keycdn.com/performance

https://blog.chiselstrike.com/vercel-benchmarks-show-turso-has-low-latencies-everywhere-what-the-data-edge-is-good-for-7407579d4c88

https://vercel.com/blog/regional-execution-for-ultra-low-latency-rendering-at-the-edge

Edge functions allow developers to modify network requests at the edge, close to the site visitors, reducing latency and giving developers the power to present relevant ads, authenticate visitors, A/B test content, and more. The article also explains the difference between edge functions and serverless functions and the benefits of using edge functions, such as decreased latency and added functionality. Some common use cases of edge functions include conditional routing, adding custom HTTP response headers, A/B testing, and authentication.

Databases can be difficult to work with, and new tools that improve the developer experience often come at a performance cost.
Prisma is an excellent tool for working with SQL databases in TypeScript, but it comes with some technical debt from version 1.
The performance of Prisma can be slow, especially in serverless environments, due to its reliance on a large GraphQL binding.
Cold starts with Prisma can take as long as 3 seconds, which is much slower than other serverless functions.
Prisma is difficult to use on the edge due to its dependence on native Rust code and JavaScript binaries that only run in Node.
Database.js is a new tool that provides primitives for the best possible performance in serverless and edge runtimes, but it does not have the same developer experience as Prisma.
Drizzle is another tool that provides a high-performance way to query databases, and the speaker plans to explore it further in future videos.

The ability to get data on the edge without performance penalties is impressive.
Moving the server close to the user can result in faster response times, but it can also increase the total distance traveled if there's more than one request being made.
It's easy to run into distance problems if you're doing SQL and then doing more SQL within a request, which is almost always going to happen.
Ideally, every request would make one query, but that's not always possible.
It often makes sense to put the server as close to the database as possible and deal with the distance of travel from the server to the user.
Edge is great at getting bytes to the user as fast as possible, but it's not great at synchronizing the bytes correctly between the database and the user.
Most companies are starting to recommend Regional Edge, where you run Edge functions in a specific region.
It's probably the right decision to run Edge functions as close as possible to the server to avoid taking a bigger penalty.
The right approach to database Edge render SSR cache Lambda is still an open question.
In the meantime, your Edge function should be as close as possible to your server to get the best performance.

export default (props) => <BlogLayout meta={meta} {...props}>{props.children}</BlogLayout>;
