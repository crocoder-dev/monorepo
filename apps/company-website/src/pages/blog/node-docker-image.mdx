import blogHeader from "../../content/images/blogs/best-react-component-libraries-2022.jpg?preset=responsive";
import BlogLayout from "../../Layouts/BlogLayout";
import ContentTable from "../../components/Blog/ContentTable";

export const meta = {
  id: "node-docker-image",
  title:
    "BLAZINGLY FAST Node.js app in Docker",
  description:
    "",
  category: "Docker",
  image: blogHeader,
  date: 1678659672751,
  updatedAt: 1678659672751,
  author: "davidabram",
  editor: "velimirujevic",
  abstract:
    "",
  pageType: "blog-posting"
};

<ContentTable tocData={props.toc} />

## Explicitly set Docker base image tag

If you set a tag for your base image, it ensures that the same image will always be used when building your Docker image. This means that your Docker image will behave consistently no matter where it is used.

I personally suggest using the latest LTS or current version of Node.js pinned to the minor version (as of March 13th that would be 18.15 or 19.7). This way you will always get the latest security patches and bug fixes, but still have a consistent build.

I recommend using the Alpine version of the Node.js image. This version is smaller and faster to build compared to the default Debian-based image. 

Additionally, using a smaller image reduces the attack surface area, making it more difficult for attackers to exploit vulnerabilities. This approach also helps prevent issues that could occur from updates to the base image that may cause problems with our application.

When we apply all this, we get a Dockerfile that looks something like:

```docker
FROM node:19.7-alpine3.16

COPY . .

RUN npm install

CMD "npm" "start"
```

## Don't use npm script to run your node app

To give you full context for this, I need to detour a bit and explain how signals work in Linux and Unix systems.

If you are certian that you don't need to know how signals work, you can skip to [this section]() to get the updated dockerfile.

### The signals problem explained in painful detail

In Linux and Unix systems, you can send signals to a running program or service to interact with it. It's a bit like semaphore lights that tell you to stop or start driving. There are lots of different signals, and each of them has an assigned number.

Signal 15 named SIGTERM is used to tell a process to shut down. Signal 9, SIGKILL is the most well-known because it lets you forcefully terminate a process.

If you want to run and stop Dockerized Node.js applications properly, your app should receive these signals properly and shouldn't ignore them. 

When you run your Dockerized Node.js application using npm start, npm will start your application and then wait for it to exit. This means that if you send a signal to your container, it will be sent to npm, not your application. This is a problem because npm does not handle signals, so it will not be able to properly shut down your application.

### An example that proves the npm scripts problem

So lets run an example that shows this issue.

Lets create a new folder and write `server.js` that sets up an HTTP server that listens on port 3000. It also registers a handler function to handle the SIGHUP signal. SIGHUP was originally designed to notify the process of a serial line drop, like old telephony stuff.

```javascript
const http = require('http');

function handle(signal) {
  console.log(`Received signal: ${signal}`);
}
process.on('SIGHUP', handle);

const server = http.createServer();

server.listen(3000);
```

The require('http') statement loads the built-in HTTP module in Node.js, which provides an easy way to create HTTP servers and clients.

The handle(signal) function is called whenever the process receives the SIGHUP signal. The console.log() statement logs a message indicating that the signal has been received.

The process.on('SIGHUP', handle) statement registers the handle() function to be called when the SIGHUP signal is received by the process.

Finally, the http.createServer() statement creates an HTTP server that listens on port 3000.

After we have saved `server.js`, let's run `npm init -f`. This should generate our `package.json`.


```json
{
  "scripts": {
    "start": "node index.js"
  }
}
```
The important this is that our `package.json`, has start script like in the previos code snippet.

Let's create a `Dockerfile` file with our current `Dockerfile` setup.

```docker
FROM node:19.7-alpine3.16

COPY . .

RUN npm install

CMD "npm" "start"
```

Lets open a terminal and run some commands.

```bash
docker build . -t npm-start-test-image

docker run --name npm-start-test-container npm-start-test

# open another terminal (or tab) 
docker kill --signal=SIGHUP npm-start-test-container
```

The first command `docker build . -t npm-start-test-image` builds a Docker image from the Dockerfile in the current directory (.) and tags it with the name npm-start-test-image.

The second command `docker run -d --name npm-start-test-container npm-start-test` starts a container from the image npm-start-test-image, in detached mode (-d), and names it npm-start-test-container.

Finally, the third command `docker kill --signal=SIGHUP npm-start-test-container` sends a SIGHUP signal to the running container named npm-start-test-container using the docker kill command. The --signal=SIGHUP option specifies that the signal being sent is SIGHUP.

And after running our last command, we expect that SIGHUP signal will be handled by our application, but it is not. Npm scripts are not forwarding signals properly.

By changing our `Dockerfile` to use `CMD "node" "server.js"` instead of `CMD "npm" "start"`, we can fix this issue.

```docker
FROM node:19.7-alpine3.16

COPY . .

RUN npm install

CMD "node" "server.js"
```

By re-running the before-mentioned bash scripts, we can see that the SIGHUP signal is now forwareded properly, and logged by our Dockerized Node.js app.

### More issues with signals not being handled properly

In Docker, there are two ways to specify the CMD directive in the Dockerfile - shellform notation `CMD "node" "server.js"` and execform notation `CMD ["node", "server.js"]`. With shellform notation, a shell interpreter wraps the process, which can cause problems with signal forwarding. The execform notation, on the other hand, directly spawns a process without a shell interpreter, ensuring signals are properly forwarded.

In a Unix-like operating system, the process with PID 1 is usually the init process, which is the first process that is started by the kernel during the boot process. The init process is responsible for starting and stopping other system processes, as well as performing other system initialization tasks.

When a Docker container is started, the process that is specified in the Dockerfile with the CMD or ENTRYPOINT directive is started with PID 1. This is because the Docker runtime treats the process specified in CMD or ENTRYPOINT as the container's main process, which is equivalent to the init process in a traditional Unix system.

Running the container's main process as PID 1 can cause some issues when handling certain signals, such as SIGTERM, because the kernel treats PID 1 differently from other process identifiers. To avoid unexpected behavior, it is recommended to use a tool like dumb-init or tini to run the container's main process as a child process of an init-like process, which can handle signals properly.

### The better CMD option

## Specify what files and where should be copied

## Run containers as a non-root user

## Set NODE_ENV=production

## Use Cache Mounts

## Use multi-stage builds

## Properly mount secrets into Docker image

```docker
FROM node

COPY . .

RUN npm install

CMD ["npm", "run", "dev"]
```


```docker
# Start with a base image that has Node.js installed
FROM node

# Copy the contents of the current directory (where the Dockerfile is located) 
# into the container's file system
COPY . .

# Run the "npm install" command inside the container to install any required 
# Node.js packages specified in the "package.json" file.
RUN npm install

# Define the command that will be executed when the container is started
# This will start the Node.js application using the "npm run dev" command.
CMD ["npm", "run", "dev"]
```

```docker
FROM node:19.7-alpine3.16

COPY . .

RUN npm install

CMD ["npm", "run", "dev"]
```


```docker
FROM node:19.7-alpine3.16

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY ./src/ .

CMD ["npm", "run", "dev"]
```

```docker
FROM node:19.7-alpine3.16

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY ./src/ .

USER node

COPY --chown=node:node ./src/ .

CMD ["npm", "run", "dev"]
```

```docker
FROM node:19.7-alpine3.16

ENV NODE_ENV production

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm ci --only-production
   
COPY ./src/ .

USER node

COPY --chown=node:node ./src/ .

EXPOSE 3000

CMD ["npm", "run", "dev"]
```

```docker
FROM node:19.7-alpine3.16

ENV NODE_ENV production

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm ci --only-production
   
COPY ./src/ .

USER node

COPY --chown=node:node ./src/ .

RUN npm install

CMD ["npm", "run", "dev"]
```

```docker
FROM node:19.7-alpine3.16

ENV NODE_ENV production

WORKDIR /usr/src/app

COPY package*.json ./

RUN --mount=type=cache,target=/usr/src/app/.npm \
  npm set cache /usr/src/app/.npm && \
  npm ci --only=production
   
COPY ./src/ .

USER node

COPY --chown=node:node ./src/ .

RUN npm install

CMD ["npm", "run", "dev"]
```

```docker
FROM node:19.6-bullseye-slim AS base

WORKDIR /usr/src/app

COPY package*.json ./

FROM base as dev

RUN --mount=type=cache,target=/usr/src/app/.npm \
  npm set cache /usr/src/app/.npm && \
  npm install

COPY . .

CMD ["npm", "run", "dev"]

FROM base as production

ENV NODE_ENV production

RUN --mount=type=cache,target=/usr/src/app/.npm \
  npm set cache /usr/src/app/.npm && \
  npm ci --only=production

USER node

COPY --chown=node:node ./src/ .

EXPOSE 3000

CMD ["npm", "run", "dev"]
```

https://hub.docker.com/_/node

export default (props) => <BlogLayout meta={meta} {...props}>{props.children}</BlogLayout>;