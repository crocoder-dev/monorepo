import blogHeader from "../../content/images/blogs/misusing-agile-is-holding-your-team-back.png?preset=responsive"
import BlogLayout from "../../Layouts/BlogLayout";
import ContentTable from "../../components/Blog/ContentTable";

export const meta = {
    id: "typescript-enums-good-bad-and-ugly",
    title: "Typescript Enums: The Good, The Bad, and The Ugly",
    description:
    "",
    image: blogHeader,
    date: 1685008800000,
    updatedAt: 1685008800000,
    author: "davidabram",
    editor: "velimirujevic",
    abstract:
    "",
    pageType: "blog-posting"
};

Enums, short for "enumerations," are a type of data structure commonly found in programming languages. An enum defines a set of named values, typically representing a collection of related constants or options.

Instead of using arbitrary values or strings to represent these options, you can use an enum to enforce type safety and provide a clear and predefined list of choices.

Before JavaScript gets their own [enums](https://github.com/rbuckton/proposal-enum), we are stuck with TypeScript. TypeScript enums seem to fit right in with types, interfaces and all-around typesafety that TypeScript, but there are curiously underutilazed in most ts codebases.

```typescript

enum TypeScript {
  Good,
  Bad,
  Ugly,
}

```

<ContentTable tocData={props.toc} />

## The Good

In TypeScript, similarly to any other language, enums can be assinged number or string value. These values can't be reassigned later in the code.

```typescript

enum Role {
  User = 10,
  Admin = 50
}

```
The cool part is that you can compare and manipulate enum values, so you can write something like:

```typescript

const userRole = Role.User;

if(userRole >= Role.Admin) {
  console.log("User is admin");
}

```

In this way you can always compare the enum values create conditional statements based on them. For example, you can write an if statement that checks whether the userRole is greater than or equal to Role.Admin


If you create an conditional statement using enums which can't never satisfied, like in the code below, tsc will throw an compile time error.

```typescript

const userRole = Role.User;

if(userRole !== Role.User || userRole !== Role.Admin) {
  // Error: This comparison appears to be unintentional 
  // because the types 'Role.User' and 'Role.Admin' have no overlap.
}

```

When creating discriminated unions, you can use an enum as their kinds. This way your conditional statements using discriminated unions don't need to have hardcoded values and can have all the upsides of enums.


```typescript

enum ShapeKind {
  Circle = "CIRCLE",
  Square = "SQUARE",
  Triangle = "TRIANGLE"
}
// 

// Shape type definition using discriminated unions
type Shape =
  | { kind: ShapeKind.Circle; radius: number }
  | { kind: ShapeKind.Square; x: number }
  | { kind: ShapeKind.Triangle; x: number; y: number };

// returns area of a shape
function area(s: Shape) {
  switch(s.kind) {
    case ShapeKind.Circle:
      return Math.PI * s.radius * s.radius;
    case ShapeKind.Square:
      return s.x * s.x;
    case ShapeKind.Triangle:
      return (s.x * s.y) / 2;
    default:
      throw new Error('Invalid shape');
  }
}

To summarize everyhting, good things about enums are:

ðŸ‘‰ Can be assigned either numeric or string values, and these values cannot be reassigned later in the code.

ðŸ‘‰ Enum values can be compared and manipulated, allowing for the creation of conditional statements based on them.

ðŸ‘‰ If a conditional statement using enums is constructed in a way that can never be satisfied, the TypeScript compiler (tsc) will throw a compile-time error, helping to catch potential issues.

ðŸ‘‰ Enums can be utilized as kinds in discriminated unions, enabling conditional statements without hardcoding values and leveraging the benefits of enums.

```
## The Bad

Let's take the next example, and try to guess if '???' will be logged.

```typescript
enum TypeScript {
  Good,
  Bad,
  Ugly,
}

const ts = TypeScript.Bad;

if(ts) {
  console.log('???')
}

```

Of course, the answer is yes. But why? If you don't assign enum values, they will be assigned to 0, 1, 2, etc.

Well that means that first enum value will be falsy, and every other value will be truthy. ðŸ˜ 

Remember how you can't reassign the enum values? Well, that's not entirely true. You can do it, but you shouldn't.

```typescript

enum TypeScript {
  Good,
  Bad,
  Ugly,
}

(TypeScript as any).Bestest = 3; // This works!

```

Can we try to make enums readonly or freeze them? 

```typescript

enum TypeScript {
  Good,
  Bad,
  Ugly,
}

Object.freeze(TypeScript); // This works!

(TypeScript as any).Bestest = 3; // This throws an error

```

How can we use Object.freeze on an enum? Well, 

TypeScript enums are actually just a syntactic sugar for objects, under the hood they are just objects with keys and values. 

Let's take a look at the compiled code:

```typescript

"use strict";
var TypeScript;
(function (TypeScript) {
    TypeScript[TypeScript["Good"] = 0] = "Good";
    TypeScript[TypeScript["Bad"] = 1] = "Bad";
    TypeScript[TypeScript["Ugly"] = 2] = "Ugly";
})(TypeScript || (TypeScript = {}));
Object.freeze(TypeScript);
TypeScript.Bestest = 3;

```

So our `TypeScript` enum is just an object that looks like:

```typescript

const TypeScript = {
  0: "Good",
  1: "Bad",
  2: "Ugly",
  Good: 0,
  Bad: 1,
  Ugly: 2,
}

```
TL;DR -> Bad things about enums are:

ðŸ‘‰ TypeScript enums are essentially objects with keys and values.

ðŸ‘‰ When enum values are not explicitly assigned, they are automatically assigned numeric values starting from 0. This means that the first enum value is falsy, while every other value is truthy.

ðŸ‘‰ Although enum values are intended to be constants and should not be reassigned, it is technically possible to do so.


## The Ugly

If you have read the previous section, you can compare and manipulate enum values, so you can write something like:

```typescript

enum ShapeKind {
  Circle = "CIRCLE",
  Square = "SQUARE",
  Triangle = "TRIANGLE"
}

const circle = ShapeKind.Circle;

if(circle === "CIRCLE") {
  console.log("Circle");
}

```

In the `if` statement above, we are comparing enum value with a string. This is a valid TypeScript code, but it's not a good practice.

Why? Well, if you change the enum value, you will have to change the string value as well. This is a recipe for disaster.

So you can rewrite the whole thing like this:

```typescript

type ShapeKind = "CIRCLE" | "SQUARE" | "TRIANGLE";

if(circle === "CIRCLE") {
  console.log("Circle");
}

```

This way you can avoid using enums, and you can still have similiar level of type safety.

In both of this examples, if you don't enforce enums, you will have random hardcoded strings in your codebase.

If you haven't noticed, enums are objects, so you can iterate over an enum.

```typescript

const enum ResponseState {
  Loading,
  Failure,
  Success,
};

for (const r in ResponseState) {
  console.log(r);
}

```

You would expect this code to log `Loading`, `Failure`, `Success`, but it will log `Loading`, `Failure`, `Success`, `0`, `1`, `2`.
Take a look at previous section, and you will see how enum is compiled to an object.




## Enums in other languages


```java

enum States {
    //...
    MASSACHUSETTS("Massachusetts",  "MA",   6981974),
    MICHIGAN     ("Michigan",       "MI",   10077331);

    private final String full;
    private final String abbr;
    private final Integer population;

    private States(String full, String abbr, Integer population) {
        this.full = full;
        this.abbr = abbr;
        this.population = population;
    }

    public String getFullName() {
        return full;
    }

    public String getAbbreviatedName() {
        return abbr;
    }

    public Integer getPopulation(){
        return population;
    }
}

```

```rust 

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
    UpdateUser(User)
}

struct User {
    username: String,
    email: String,
    age: i32
}

fn main() {
    let message_move = Message::Move { x: 10, y: 20 };
    let message_write = Message::Write(String::from("Hello, world!"));
    let message_change_color = Message::ChangeColor(255, 255, 255);
    let message_update_user = Message::UpdateUser(User {
        username: String::from("davidabram"),
        email: String::from("hello@crocoder.dev"),
        age: 33
    });
}

```


export default (props) => <BlogLayout meta={meta} {...props}>{props.children}</BlogLayout>;
