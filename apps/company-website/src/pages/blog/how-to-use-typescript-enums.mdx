import blogHeader from "../../content/images/blogs/misusing-agile-is-holding-your-team-back.png?preset=responsive"
import BlogLayout from "../../Layouts/BlogLayout";
import ContentTable from "../../components/Blog/ContentTable";

export const meta = {
    id: "typescript-enums-good-bad-and-ugly",
    title: "Typescript Enums: The Good, The Bad, and The Ugly",
    description:
    "",
    image: blogHeader,
    date: 1685008800000,
    updatedAt: 1685008800000,
    author: "davidabram",
    editor: "velimirujevic",
    abstract:
    "",
    pageType: "blog-posting"
};

Enums, short for "enumerations," are a type of data structure commonly found in programming languages. An enum defines a set of named values, typically representing a collection of related constants or options.

Instead of using arbitrary values or strings to represent these options, you can use an enum to enforce type safety and provide a clear and predefined list of choices.

Before JavaScript gets their own [enums](https://github.com/rbuckton/proposal-enum), we are stuck with TypeScript. TypeScript enums seem to fit right in with types, interfaces and all-around typesafety that TypeScript, but there are curiously underutilazed in most ts codebases.

```typescript

enum TypeScript {
  Good,
  Bad,
  Ugly,
}

```

<ContentTable tocData={props.toc} />

## The Good

In TypeScript, similarly to any other language, enums can be assinged number or string value. These values can't be reassigned later in the code.

```typescript

enum Role {
  User = 10,
  Admin = 50
}

```
The cool part is that you can compare and manipulate enum values, so you can write something like:

```typescript

const userRole = Role.User;

if(userRole >= Role.Admin) {
  console.log("User is admin");
}

```
In this way you can always compare enum values and c

If you create an conditional statement using enums which can't never satisfied, like in the code below, tsc will throw an compile time error.

```typescript

const userRole = Role.User;

if(userRole !== Role.User || userRole !== Role.Admin) {
  // Error: This comparison appears to be unintentional 
  // because the types 'Role.User' and 'Role.Admin' have no overlap.
}

```

When creating discriminated unions, you can use an enum as their kinds. This way your conditional statements using discriminated unions don't need to have hardcoded values and can have all the upsides of enums.


```typescript

enum ShapeKind {
  Circle = "CIRCLE",
  Square = "SQUARE",
  Triangle = "TRIANGLE"
}
// 

// Shape type definition using discriminated unions
type Shape =
  | { kind: ShapeKind.Circle; radius: number }
  | { kind: ShapeKind.Square; x: number }
  | { kind: ShapeKind.Triangle; x: number; y: number };

// returns area of a shape
function area(s: Shape) {
  switch(s.kind) {
    case ShapeKind.Circle:
      return Math.PI * s.radius * s.radius;
    case ShapeKind.Square:
      return s.x * s.x;
    case ShapeKind.Triangle:
      return (s.x * s.y) / 2;
    default:
      throw new Error('Invalid shape');
  }
}

```
## The Bad

```typescript

enum ShapeKind {
  Circle = "CIRCLE",
  Square = "SQUARE",
  Triangle = "TRIANGLE"
}

const circle = ShapeKind.Circle;

if(circle === "CIRCLE") {
  console.log("Circle");
}

```

```typescript

type ShapeKind = "CIRCLE" | "SQUARE" | "TRIANGLE";

```



## The Ugly

```typescript

const enum ResponseState {
  Empty,
  Loading,
  Failure,
  Success,
};

// Why can we iterate over an enum?
for (const r in ResponseState) {
  console.log(r);
}

```


## Enums in other languages


```java

enum States {
    //...
    MASSACHUSETTS("Massachusetts",  "MA",   6981974),
    MICHIGAN     ("Michigan",       "MI",   10077331);

    private final String full;
    private final String abbr;
    private final Integer population;

    private States(String full, String abbr, Integer population) {
        this.full = full;
        this.abbr = abbr;
        this.population = population;
    }

    public String getFullName() {
        return full;
    }

    public String getAbbreviatedName() {
        return abbr;
    }

    public Integer getPopulation(){
        return population;
    }
}

```

```rust 

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
    UpdateUser(User)
}

struct User {
    username: String,
    email: String,
    age: i32
}

fn main() {
    let message_move = Message::Move { x: 10, y: 20 };
    let message_write = Message::Write(String::from("Hello, world!"));
    let message_change_color = Message::ChangeColor(255, 255, 255);
    let message_update_user = Message::UpdateUser(User {
        username: String::from("davidabram"),
        email: String::from("hello@crocoder.dev"),
        age: 33
    });
}

```


export default (props) => <BlogLayout meta={meta} {...props}>{props.children}</BlogLayout>;
