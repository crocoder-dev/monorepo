
import blogHeader from "../../content/images/blogs/misusing-agile-is-holding-your-team-back.png?preset=responsive"
import BlogLayout from "../../Layouts/BlogLayout";
import ContentTable from "../../components/Blog/ContentTable";

export const meta = {
    id: "from-simple-golang-docker-image-to-production-ready-perfection",
    title: "From simple Golang docker image to production-ready perfection",
    description:
    "", 
    category: "Docker", 
    image: blogHeader,
    date: 1689628390000,
    updatedAt: 1689628390000, 
    author: "davidabram",
    editor: "velimirujevic",
    abstract:
    "",
    pageType: "blog-posting"
};

Ahoy there, fellow Gophers! Welcome to our exciting Dockerizing adventure, where we'll transform a simple Golang Docker image into a production-ready masterpiece. As aspiring Docker captains, we'll navigate through increasing complexity, optimizing our images step by step. So, tighten your ship's rigging, and let's set sail!

<ContentTable tocData={props.toc} />

## A Humble Beginning

Our journey commences with a basic Golang Dockerfile:

```docker
FROM golang

WORKDIR /app 

COPY . .

RUN go mod download

CMD ["go", "run", "./main.go"]
```

In this Dockerfile, we use the official Golang base image, set the working directory to /app, copy the application files, download module dependencies using go mod download, and finally run our Golang application with go run.

## Pinning Versions and Embracing Debian 

To ensure stability and consistency, we'll pin the Golang version and switch to Debian for more robust build utilities:

```docker

# Next, we embrace the powerful and versatile Debian base image üê≥
# This choice grants us easier access to essential build utilities and a robust development environment.
FROM golang:1.20-bullseye AS build

WORKDIR /app 

COPY . .

RUN go mod download

CMD ["go", "run", "./main.go"]
```

By specifying the Golang version, we ensure our image is built with the same version every time, reducing the risk of unexpected behavior.

## Compiling for Performance

To enhance runtime performance, we'll compile the Golang application during the build stage:

```docker

# Next, we embrace the powerful and versatile Debian base image üê≥
# This choice grants us easier access to essential build utilities and a robust development environment.
FROM golang:1.20-bullseye AS build

WORKDIR /app 

COPY . .

RUN go mod download

# During this stage, we compile our application ahead of time, avoiding any runtime surprises.
# The resulting binary, web-app-golang, will be our steadfast companion in the final leg of our journey.
RUN go build -o web-app-golang

CMD ["./web-app-golang"]
```

By compiling the application beforehand, we eliminate the need to compile it at runtime, leading to faster startup times.

## Safeguarding with Layer Caching

To optimize caching and speed up the installation of dependencies, we'll copy only the necessary files:

```docker

# Next, we embrace the powerful and versatile Debian base image üê≥
# This choice grants us easier access to essential build utilities and a robust development environment.
FROM golang:1.20-bullseye AS build

WORKDIR /app 

# We optimize our path to discovery, selecting only the files required to install dependencies. üß≠
# With this choice, we unlock the potential of better layer caching, improving our image's efficiency.
COPY go.mod go.sum ./

RUN go mod download

COPY . .

# During this stage, we compile our application ahead of time, avoiding any runtime surprises.
# The resulting binary, web-app-golang, will be our steadfast companion in the final leg of our journey.
RUN go build -o web-app-golang

CMD ["./web-app-golang"]
```

By copying only the go.mod and go.sum files before running go mod download, we utilize Docker's caching mechanism effectively, reducing build times.

## A Two-Stage Expedition

To create a smaller and more secure image, we'll embark on a two-stage journey:

```docker

# Use separate stage for building image
# Next, we embrace the powerful and versatile Debian base image üê≥
# This choice grants us easier access to essential build utilities and a robust development environment.
FROM golang:1.20-bullseye AS build

WORKDIR /app 

# We optimize our path to discovery, selecting only the files required to install dependencies. üß≠
# With this choice, we unlock the potential of better layer caching, improving our image's efficiency.
COPY go.mod go.sum ./

RUN go mod download

COPY . .

# During this stage, we compile our application ahead of time, avoiding any runtime surprises.
# The resulting binary, web-app-golang, will be our steadfast companion in the final leg of our journey.
# We strategically add flags to statically link our binary.
RUN go build \
  -ldflags="-linkmode external -extldflags -static" \
  -tags netgo \
  -o web-app-golang

# Use separate stage for deployable image
FROM scratch

WORKDIR /

# Copy the binary from the build stage
COPY --from=build /app/web-app-golang api-golang

CMD ["/web-app-golang"]
```

The two-stage approach allows us to build the binary in one stage and use a minimal scratch image for the deployable container. This significantly reduces the image size and eliminates any unnecessary components, making it more secure.

## Setting Sail with Environment Configurations

To configure our Golang application for various environments, we'll add environment variables and port configurations:

```docker

# Use separate stage for building image
# Next, we embrace the powerful and versatile Debian base image üê≥
# This choice grants us easier access to essential build utilities and a robust development environment.
FROM golang:1.20-bullseye AS build

WORKDIR /app 

# We optimize our path to discovery, selecting only the files required to install dependencies. üß≠
# With this choice, we unlock the potential of better layer caching, improving our image's efficiency.
COPY go.mod go.sum ./

RUN go mod download

COPY . .

# During this stage, we compile our application ahead of time, avoiding any runtime surprises.
# The resulting binary, web-app-golang, will be our steadfast companion in the final leg of our journey.
# We strategically add flags to statically link our binary.
RUN go build \
  -ldflags="-linkmode external -extldflags -static" \
  -tags netgo \
  -o web-app-golang

# Use separate stage for deployable image
FROM scratch

# Set gin mode
ENV GIN_MODE=release

WORKDIR /

# Copy the binary from the build stage
COPY --from=build /app/web-app-golang api-golang

# Indicate expected port
EXPOSE 8080

CMD ["/web-app-golang"]
```

By setting environment variables like GIN_MODE=release and indicating the expected port (EXPOSE 8080), we ensure our application runs optimally in various environments.

## Anchoring with Non-Root Users

For heightened security, we'll anchor our ship with a non-root user:

```docker

# Use separate stage for building image
# Next, we embrace the powerful and versatile Debian base image üê≥
# This choice grants us easier access to essential build utilities and a robust development environment.
FROM golang:1.20-bullseye AS build

# Add non-root user
RUN useradd -u 1001 nonroot

WORKDIR /app 

# We optimize our path to discovery, selecting only the files required to install dependencies. üß≠
# With this choice, we unlock the potential of better layer caching, improving our image's efficiency.
COPY go.mod go.sum ./

# Use cache mount to speed up install of existing dependencies
RUN --mount=type=cache,target=/go/pkg/mod \
  --mount=type=cache,target=/root/.cache/go-build \
  go mod download

COPY . .

# Compile healthcheck
RUN go build \
  -ldflags="-linkmode external -extldflags -static" \
  -tags netgo \
  -o healthcheck \
  ./healthcheck/healthcheck.go

# During this stage, we compile our application ahead of time, avoiding any runtime surprises.
# The resulting binary, web-app-golang, will be our steadfast companion in the final leg of our journey.
# We strategically add flags to statically link our binary.
RUN go build \
  -ldflags="-linkmode external -extldflags -static" \
  -tags netgo \
  -o web-app-golang

# Use separate stage for deployable image
FROM scratch

# Set gin mode
ENV GIN_MODE=release

WORKDIR /

# Copy the passwd file
COPY --from=build /etc/passwd /etc/passwd

# Copy the healthcheck binary from the build stage
COPY --from=build /app/healthcheck/healthcheck healthcheck

# Copy the app binary from the build stage
COPY --from=build /app/web-app-golang api-golang

# Use non-root user
USER nonroot

# Indicate expected port
EXPOSE 8080

CMD ["/web-app-golang"]
```

By using a non-root user (nonroot), we reduce the risk of potential security vulnerabilities.

## A Multistage Adventure with Development Delights

As we sail through development waters, we'll make our lives easier with delightful tools like "air" for hot reloading and "dlv" for debugging:

```docker

# Use separate stage for building image
# Next, we embrace the powerful and versatile Debian base image üê≥
# This choice grants us easier access to essential build utilities and a robust development environment.

FROM golang:1.20-bullseye AS build-base

WORKDIR /app 

# We optimize our path to discovery, selecting only the files required to install dependencies. üß≠
# With this choice, we unlock the potential of better layer caching, improving our image's efficiency.
COPY go.mod go.sum ./

# Use cache mount to speed up install of existing dependencies
RUN --mount=type=cache,target=/go/pkg/mod \
  --mount=type=cache,target=/root/.cache/go-build \
  go mod download

FROM build-base AS dev

# Install air for hot reload & delve for debugging
RUN go install github.com/cosmtrek/air@latest && \
  go install github.com/go-delve/delve/cmd/dlv@latest

COPY . .

CMD ["air", "-c", ".air.toml"]
```

Now, our development voyage is smoother with hot reloading and debugging on the fly!

## Raising the Production Flag

Production awaits, and we'll tighten security and optimize our deployment with a final stage:

```docker

# Use separate stage for building image
# Next, we embrace the powerful and versatile Debian base image üê≥
# This choice grants us easier access to essential build utilities and a robust development environment.
FROM golang:1.20-bullseye AS build-base

WORKDIR /app 

# We optimize our path to discovery, selecting only the files required to install dependencies. üß≠
# With this choice, we unlock the potential of better layer caching, improving our image's efficiency.
COPY go.mod go.sum ./

# Use cache mount to speed up install of existing dependencies
RUN --mount=type=cache,target=/go/pkg/mod \
  --mount=type=cache,target=/root/.cache/go-build \
  go mod download

FROM build-base AS dev

# Install air for hot reload & delve for debugging
RUN go install github.com/cosmtrek/air@latest && \
  go install github.com/go-delve/delve/cmd/dlv@latest

COPY . .

CMD ["air", "-c", ".air.toml"]

FROM build-base AS build-production

# Add non-root user
RUN useradd -u 1001 nonroot

COPY . .

# Compile healthcheck
RUN go build \
  -ldflags="-linkmode external -extldflags -static" \
  -tags netgo \
  -o healthcheck \
  ./healthcheck/healthcheck.go

# During this stage, we compile our application ahead of time, avoiding any runtime surprises.
# The resulting binary, web-app-golang, will be our steadfast companion in the final leg of our journey.
# We strategically add flags to statically link our binary.
RUN go build \
  -ldflags="-linkmode external -extldflags -static" \
  -tags netgo \
  -o web-app-golang

# Use separate stage for deployable image
FROM scratch

# Set gin mode
ENV GIN_MODE=release

WORKDIR /

# Copy the passwd file
COPY --from=build-production /etc/passwd /etc/passwd

# Copy the healthcheck binary from the build stage
COPY --from=build-production /app/healthcheck/healthcheck healthcheck

# Copy the app binary from the build stage
COPY --from=build-production /app/web-app-golang api-golang

# Use non-root user
USER nonroot

# Indicate expected port
EXPOSE 8080

CMD ["/web-app-golang"]
```

Now, our ship is battle-ready for the production storm!

## Conclusion

Ahoy, brave sailors! We've weathered rough waters and perfected our Golang Docker image from simple to production-ready. From pinning versions, embracing Debian, and optimizing caching, to multistaging, healthchecks, and delightful development tools, our Dockerizing journey is complete.

You are now a skilled Docker captain, capable of steering your Golang applications towards smooth and secure deployments in any environment.

Set your sails high, navigate the production seas, and may your Golang Docker images sail with pride! Fair winds, and happy coding! üö¢üêπüêä


export default (props) => <BlogLayout meta={meta} {...props}>{props.children}</BlogLayout>;
