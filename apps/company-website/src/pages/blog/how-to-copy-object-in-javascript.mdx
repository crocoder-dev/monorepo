import blogHeader from "../../content/images/blogs/how-to-clone-object-in-javascript.png?preset=responsive";
import BlogLayout from "../../Layouts/BlogLayout";
import NonHSubtitle from "../../components/Blog/NonHSubtitle";
import ContentTable from "../../components/Blog/ContentTable";

export const meta = {
  id: "how-to-copy-object-in-javascript",
  title: "All the ways you can copy an object in JavaScript",
  description:
    "In JavaScript, you cannot clone an object just by assigning its value to another variable, but you can use any of these techniques to shallow or deep clone an object!",
  category: "Code Bits",
  image: blogHeader,
  date: 1635894000000,
  updatedAt: 1635894000000,
  author: "davidabram",
  editor: "velimirujevic",
  abstract:
    "In JavaScript, object cloning isn't as obvious as it seems. You can't just assign the value of one object to another variable and create a copy of it. The problem is related to the data types you can use in JavaScript.There are two groups of JavaScript data types; primitive values and objects. Primitive values are Boolean, Null, Undefined, Number, BigInt, String & Symbol. Objects are all other data types that are collections of properties (including Arrays!).The big difference between primitive values and objects happens when you try using the `=` operator.",
  pageType: "blog-posting"
};


<ContentTable tocData={props.toc} />

## Shallow and Deep copy

Let's say you have an object in JavaScript that contains some values, including a nested object or array. When you make a copy of this object, you need to decide whether you want to make a shallow copy or a deep copy.

A shallow copy means that you create a new reference to the original object, but any changes you make to the copied object will also affect the original object. It's like having two names for the same thing. If you change one name, the other name will also reflect the change.

A deep copy means that you create a completely new object or array with its own memory reference. This means that any changes you make to the copied object will not affect the original object. It's like making a photocopy of a page. If you make any changes to the photocopy, the original page will remain the same.

So, if you want to create a new object that has the same values as the original object, but you don't want to change the original object, you should use a deep copy. However, if you don't mind the original object changing along with the copied object, you can use a shallow copy.

It's important to note that deep copying can be more resource-intensive than shallow copying, especially for large objects. Therefore, you should choose the appropriate copy method based on your specific needs.

## Shallow copying

### Spread operator (...)
The spread operator creates a new object with the same properties as the original object, but any properties of the original object that are themselves objects will still be references to the same objects in memory.

```js
const originalObject = { a: 1, b: { c: 2 } };
const copiedObject = { ...originalObject };

console.log(copiedObject); // { a: 1, b: { c: 2 } }
```
### Object.assign()

The Object.assign() method creates a new object that has the same properties as the original object. However, if any properties of the original object are also objects, they will still be references to the same objects in memory. This means that any changes made to these object properties in the new object will also be reflected in the original object.

```js
const originalObject = { a: 1, b: { c: 2 } };
const copiedObject = Object.assign({}, originalObject);

console.log(copiedObject); // { a: 1, b: { c: 2 } }
```

### Object.entries() and Object.fromEntries()

The Object.entries() method creates an array of arrays, each containing a key-value pair from the original object. We can then use the Object.fromEntries() method to create a new object from these key-value pairs.

```js
const originalObject = { a: 1, b: { c: 2 } };
const copiedObject = Object.fromEntries(Object.entries(originalObject));

console.log(copiedObject); // { a: 1, b: { c: 2 } }
```

As with the other two methods, any properties of the original object that are themselves objects will still be references to the same objects in memory.

All three methods of shallow copying objects in JavaScript create a new object with the same properties as the original object, but any properties of the original object that are themselves objects will still be references to the same objects in memory. The spread operator and Object.assign() methods are simpler to use than the Object.entries() and Object.fromEntries() methods, but all three methods achieve the same result.

## Deep copying

### JSON.parse() and JSON.stringify()

JSON.stringify() and JSON.parse() are methods that can be used for deep cloning objects in JavaScript. These methods work by first converting the object to a JSON string using JSON.stringify(), and then creating a new object from the JSON string using JSON.parse().

One limitation of using JSON.stringify() and JSON.parse() for deep cloning is that they cannot clone functions or objects that have circular references (i.e., objects that reference themselves in a loop). Another big limitation is that you cannot copy symbols or objects that have properties that are symbols.

```js
const originalObject = { a: 1, b: { c: 2 } };
const copiedObject = JSON.parse(JSON.stringify(originalObject));

console.log(copiedObject); // { a: 1, b: { c: 2 } }
```

### structuredClone()

structuredClone() is a the newest method that can be used for deep cloning objects in JavaScript. It is a method that is part of the Web Share API, but it can also be used independently of the Web Share API.
The structured clone copies complex JavaScript objects. It is used internally when invoking structuredClone(), to transfer data between Workers via postMessage(), storing objects with IndexedDB, or copying objects for other APIs.

```js
const originalObject = { a: 1, b: { c: 2 } };
const copiedObject = structuredClone(originalObject);

console.log(copiedObject); // { a: 1, b: { c: 2 } }
```
This method creates a new object that is a deep copy of the original object, including any functions or objects with circular references.

## Perfomance



export default (props) => <BlogLayout meta={meta} {...props}>{props.children}</BlogLayout>;
