import blogHeader from "../../content/images/blogs/how-to-properly-showcase-your-coding-projects.jpg?preset=responsive";
import BlogLayout from "../../Layouts/BlogLayout";

export const meta = {
  id: "omit",
  title: "Omit",
  description:
    "",
  category: "After Work Talks",
  image: blogHeader,
  date: 1644227110000,
  updatedAt: 1644227110000,
  author: "davidabram",
  editor: "velimirujevic",
  abstract:
    "",
  pageType: "blog-posting"
};

Let's dive into the world of TypeScript and acquaint ourselves with the clever tool known as Omit. This little buddy is your reliable ally when you're cooking up a fresh type and want to leave out a couple of properties from a preexisting type. It's a simple and effective trick, folks!

## How to use Omit

Imagine you've got this type describing someone's particulars ‚Äì you know, their name, age, and email:

```typescript
type Person = {
    name: string;
    age: number;
    email: string;
};
```

Now, picture this: you want a type that's almost identical to `Person`, but minus the email part.

Behold the magic:

```typescript
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

type PersonWithoutEmail = Omit<Person, 'email'>;
```

What we're doing here is crafting a fresh type called `PersonWithoutEmail` using the Omit tool. It's as if we're saying, "Hey, I'd like a version of `Person`, but without that 'email' thing, alright?"

And check this out:

```typescript
const person: PersonWithoutEmail = {
    name: 'Alice',
    age: 30,
    // We're not bothering with 'email' here!
};

console.log(person); // Output: { name: 'Alice', age: 30 }
```

With Omit, you've got yourself a brand new `PersonWithoutEmail` object ‚Äì email not included. It's a nifty and efficient way to whip up a type that's got just the stuff you need.

## Omit and unions don't play well

Alright, pals, let's hop onto the TypeScript train and have a chat about something called Omit. Now, don't be fooled, Omit and Pick can sometimes act a little quirky when dealing with unions. But don't fret, there's a hero in town named DistributiveOmit that's here to save the day! üí™

Imagine you've got a union of types. You know, like when you've got two different flavors mingling together:

```typescript
type Union = { a: string; b: number } | { c: boolean; }
```

You might think you can just use Omit to get rid of, let's say, the "a" property from this union. But hang onto your hats! Omit and Pick might not give you exactly what you expect.

Let's give it a whirl:

```typescript
type BadResult = Omit<Union, "a">;
```

You'd imagine it'd drop "a" from both parts of the union, right? But hold up, TypeScript's got some quirks. It kind of flattens the union, and "a" disappears from the whole thing! ü•û

Enter DistributiveOmit, our star of the show! üéâ This little champ uses a conditional type to make sure that the omit action happens separately on each member of the union.

Check this out:

```typescript
type DistributiveOmit<T, K extends PropertyKey> = T extends any ? Omit<T, K> : never;

type GoodResult = DistributiveOmit<Union, "a">;
```

Now, we're cooking with gas! DistributiveOmit ensures that the omit operation takes place individually on each part of the union. It's like saying, "Hey, TypeScript, make sure you treat each flavor of the union separately, got it?"

And guess what? DistributiveOmit shines when you want to keep things nice and neat, even when unions are in play.


## Omit plays well with extending interfaces

Hold onto your hats, because TypeScript's got a flavor-packed trick up its sleeve! Did you know that the 'Omit' utility type can turn you into a customization wizard for your interfaces? You can extend those interfaces, give 'em a twist, and even swap out toppings (properties) without breaking a sweat! üçîüçó

Let's break it down with an example that'll make your coding taste buds tingle:

Imagine we've got a delectable `Toppings` type for all you burger enthusiasts:

```typescript
type Toppings = 'lettuce' | 'onion' | 'tomato' | 'mayo' | 'ketchup'; 
```

And then, say hello to our trusty `Cheeseburger` interface, complete with all the burger goodness:

```typescript
interface Cheeseburger {
    bun: boolean;
    cheese: boolean;
    protein: 'beef';
    toppings: Toppings[];
}
```

But wait, there's more! TypeScript's about to sprinkle some magic. Enter the valiant `ChickenSandwich` interface. üêî‚ú® We're extending it from `Cheeseburger` with a twist! We're using the 'Omit' utility type to remove the 'protein' property from the 'Cheeseburger' and swap it with our poultry delight.

```typescript
interface ChickenSandwich extends Omit<Cheeseburger, 'protein'> {
    protein: 'chicken';
}
```

Did you catch that? With a dash of 'Omit', we're crafting a fresh interface that's like a burger's sibling. We're keeping everything from the `Cheeseburger`, but with a little

 twist: swapping out the 'protein' for 'chicken'. Voil√†! You've just whipped up a `ChickenSandwich` that's like the cheeseburger's cool cousin.

## Omit isn't strict at all

Hey there, folks! Let's keep exploring the fantastic world of TypeScript! We've stumbled upon a rather interesting phenomenon: those moments when you're almost expecting an error party to start, but TypeScript's like, "Nah, I got this!" ü§∑‚Äç‚ôÇÔ∏è

Picture this: you've got this cool type setup with a `Person`:

```typescript
type Person = {
  name: string,
  age: number
}
```

Now, your inquisitive side takes over, and you decide to fashion a `NameOnly` type using Omit. You're thinking, "Let's drop 'age' and, oh, why not toss in some 'anyOtherRandomCrap' just for fun?"

```typescript
type NameOnly = Omit<Person, 'age' | 'anyOtherRandomCrap'>;
```

Now, here's the twist: You're half expecting TypeScript to raise its hand and say, "Hold on, that 'anyOtherRandomCrap' isn't even in `Person`!" But guess what? TypeScript seems pretty chill about the whole random shenanigans. It's like, "Yeah, I see what you're doing. No big deal!"

But buckle up, because here comes the superhero solution: StrictOmit! ü¶∏‚Äç‚ôÇÔ∏è

```typescript
type StrictOmit<T, K extends keyof T> = Omit<T, K>;
```

This little gem is like a "strict mode" for Omit. It's got your back and says, "Hey, if you're gonna omit stuff, let's make sure that stuff actually exists in the type you're playing with."

So now, if you go for StrictOmit:

```typescript
type NameOnly = StrictOmit<Person, 'age' | 'anyOtherRandomCrap'>;
```

Boom! TypeScript's gonna give you a heads-up, saying, "Hold your horses! That 'anyOtherRandomCrap' isn't part of the `Person` type. Let's keep it real."

## Make a rule to use DeepOmit rather than Omit

Alright, fellow code adventurers, strap in, because we're setting out on a quest to establish StrictOmit as the sovereign ruler of the type realm! üè∞‚öîÔ∏è We've unlocked the magic of StrictOmit, and now we're setting up our guardians, the ESLint rules, to steer our fellow developers toward this newfound treasure trove.

Imagine this: you've unveiled the majestic StrictOmit, a tool that empowers you to forge types with precision. You want your fellow developers to tap into this power and craft types that are harmonious, clean, and robust. But how do you guide them in the right direction? Fear not, for the ESLint rules are here to save the day!

Behold the illustrious `eslintrc.js` file, where we weave our enchantment:

```javascript
module.exports = {
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
  rules: {
    "@typescript-eslint/ban-types": [
      "error",
      {
        "types": {
          "Omit": "Use StrictOmit from type.utils instead",
        },
        "extendDefaults": true
      }
    ]
}
```

With these lines of code, we're akin to sagacious sorcerers, casting a spell to ensure that every developer embarks on the path of StrictOmit. The "@typescript-eslint/ban-types" rule is our trusty wand, gently whispering a reminder: "Hey, friend, if you're contemplating Omit, consider StrictOmit from type.utils!"

Envision a world where every developer speaks the same type language, follows the same conventions, and crafts types that seamlessly align. This is the symphony of coherence we're orchestrating with these ESLint rules. By guiding everyone toward StrictOmit, we're painting a harmonious canvas of clean, efficient, and unified code.

Our journey to elevate StrictOmit marches forward with ESLint rules as our steadfast allies. We're not just forging types; we're nurturing a coding culture where excellence is the norm. And if someone inadvertently takes a detour and tries to use the old Omit, have no fear! ESLint is there to gently redirect them onto the correct path.

## Conclusion

And there you have it, our journey through the realm of TypeScript's Omit and its various facets. We've delved into the power of Omit, a versatile tool that allows us to create refined types by omitting specific properties. From crafting tailored types with Omit to navigating the intricacies of unions using DistributiveOmit, we've explored the art of type manipulation.

Our exploration led us to StrictOmit, a type that brings a higher level of precision by ensuring properties are omitted only when they truly exist. We also ventured into the world of interface customization, using Omit to create unique variations while maintaining the essence of the original.

But our journey doesn't end here. Armed with this newfound knowledge, you're equipped to wield TypeScript's capabilities to create clear, effective, and maintainable types. By embracing the power of omission, you're on the path to crafting code that communicates intentions clearly and elegantly.

As you continue your coding endeavors, remember that the world of TypeScript is full of opportunities to refine your code and enhance your development experience. May your coding adventures be filled with creativity, innovation, and the joy of mastering your craft. Until next time, try to write less bugs than I do! üöÄüîç

export default (props) => <BlogLayout meta={meta} {...props}>{props.children}</BlogLayout>;
