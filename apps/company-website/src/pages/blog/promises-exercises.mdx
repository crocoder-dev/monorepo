import Column from "../../components/Blog/CodeExample/Column";
import Row from "../../components/Blog/CodeExample/Row";
import ListToggle from "../../components/Blog/CodeExample/ListToggle";
import blogHeader from "../../content/images/blogs/placeholder.png?preset=responsive";
import BlogLayout from "../../Layouts/BlogLayout";
import NonHSubtitle from "../../components/Blog/NonHSubtitle";

export const meta = {
    id: "hello",
    title: "Promises - Code Exercises", 
    description: "",
    category: "LEARN JAVASCRIPT",
    hideHeaderImage: true,
    image: blogHeader,
    date: 1703616983438,
    updatedAt: 1703616983438,
    author: "davidabram",
    editor: "velimirujevic",
    abstract: "",
    pageType: "blog-posting"
};

## 50% of the time works 100% of the time

Create a JavaScript Promise that, after a delay of 2 seconds, either resolves with the message "Hello World" or rejects with the error message "Error occurred". 

The outcome (resolve or reject) should be determined by a random condition, ensuring a 50/50 chance of either occurring each time the code runs.

<NonHSubtitle>Helpful links</NonHSubtitle>

- [setTimeout()](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout)
- [Math.random()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)
- [Promise() constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise)
- [Promise.prototype.then()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)
- [Promise.prototype.catch()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch)

<Row>

  <Column>

<NonHSubtitle>Input</NonHSubtitle>

```javascript
randomPromise
  .then((message) => {
    console.log(message);
  })
  .catch((error) => {
    console.error(error);
  });
```

  </Column>

  <Column>

<NonHSubtitle>Result</NonHSubtitle>

```javascript
// 50% of the time console.logs
"Hello World"

// 50% of the time console.errors
"Error occurred"
```

  </Column>

</Row>

<ListToggle title="Solution">

```javascript
const randomPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // Randomly decide whether to resolve or reject
    const shouldResolve = Math.random() > 0.5;

    if (shouldResolve) {
      resolve("Hello World");
    } else {
      reject("Error occurred");
    }
  }, 2000);
});

randomPromise
  .then((message) => {
    console.log(message);
  })
  .catch((error) => {
    console.error(error);
  });
```
The Promise is constructed with an executor function that invokes **`setTimeout`** to simulate a 2-second asynchronous operation.

Within the **`setTimeout`** callback, a random boolean **`shouldResolve`** is determined using **`Math.random() > 0.5`**. This expression has a 50% chance to evaluate to true or false.

The Promise is resolved with "Hello World" if shouldResolve is true, and rejected with "Error occurred" if false. **`Promise.then()`** and **`Promise.catch()`** methods are attached to the Promise to handle its resolution and rejection, respectively.

Each execution of this code has an equal probability of either resolving or rejecting the Promise, demonstrating the handling of different Promise states in a single code structure.

</ListToggle>


## Chain some Math with Promises

Input a number, double it, increase it by 10, and then multiply by 3.

Each operation should be in seperate Promise and then chained together.

<NonHSubtitle>Helpful links</NonHSubtitle>

- [Promise() constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise)
- [Promise.prototype.then()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)

<Row>

  <Column>

<NonHSubtitle>Input</NonHSubtitle>

```javascript
const value = 5;

double(value)
  .then(addTen)
  .then(multiplyByThree)
  .then((result) => {
    console.log(result);
  });

```

  </Column>

  <Column>

<NonHSubtitle>Result</NonHSubtitle>

```javascript
40
```

  </Column>

</Row>

<ListToggle title="Solution">

```javascript

const value = 5;

const double = (value) => new Promise((resolve) => resolve(value * 2));

const addTen = (value) => new Promise((resolve) => resolve(value + 10));

const multiplyByThree = (value) => new Promise((resolve) => resolve(value * 3));

double(value)
  .then(addTen)
  .then(multiplyByThree)
  .then((result) => {
    console.log(result);
  });

```

Each function returns a Promise that performs an arithmetic operation and resolves immediately. 

The initial value is passed through the chain, undergoing each operation sequentially. 

The final result is logged, demonstrating the cumulative effect of the chained operations.

</ListToggle>


## Fetch data in parallel

Using fetchSimulator simulate fetching data from three different URLs in parallel. 

Each "fetch" will be represented by a Promise that resolves after a delay taken from delays array. 

Use Promise.all to wait for all these Promises to resolve and then process the results.

<NonHSubtitle>Helpful links</NonHSubtitle>

- [Promise.all()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
- [Promise.prototype.then()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)

<Row>

  <Column>

<NonHSubtitle>Input</NonHSubtitle>

```javascript

const delays = [800, 1200, 1000];

const fetchSimulator = (url, delay) => {
    return new Promise(resolve => setTimeout(() => resolve(`Data from ${url}`), delay));
};

```

  </Column>

</Row>

<ListToggle title="Solution">

```javascript
const delays = [800, 1200, 1000];

const fetchSimulator = (url, delay) => {
  return new Promise(resolve => setTimeout(() => resolve(`Data from ${url}`), delay));
};

const data1 = fetchSimulator('https://crocoder.dev/data1', delays[0]);
const data2 = fetchSimulator('https://crocoder.dev/data2', delays[1]);
const data3 = fetchSimulator('https://crocoder.dev/data3', delays[2]);

Promise.all([data1, data2, data3])
  .then((responses) => {
    console.log('All data fetched:', responses);
  });

```
Three simulated fetch requests are created with different delays. **`Promise.all`** is used to wait for all these Promises to resolve.

Once all Promises resolve, their results are processed together, showcasing the ability of **`Promise.all`** to synchronize multiple asynchronous operations.

</ListToggle>



## The fastest response wins

Using fetchSimulator simulate fetching data from three different URLs with a twist. 

Each "fetch" will be represented by a Promise that resolves after a delay taken from delays array. 

Use Promise.race to get the fastest response!

<NonHSubtitle>Helpful links</NonHSubtitle>

- [Promise.race()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)
- [Promise.prototype.then()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)

<Row>

  <Column>

<NonHSubtitle>Input</NonHSubtitle>

```javascript

const delays = [800, 1200, 1000];

const fetchSimulator = (url, delay) => {
    return new Promise(resolve => setTimeout(() => resolve(`Data from ${url}`), delay));
};


```

  </Column>

</Row>

<ListToggle title="Solution">

```javascript
const delays = [800, 1200, 1000];

const fetchSimulator = (url, delay) => {
  return new Promise(resolve => setTimeout(() => resolve(`Data from ${url}`), delay));
};

const data1 = fetchSimulator('https://crocoder.dev/data1', delays[0]);
const data2 = fetchSimulator('https://crocoder.dev/data2', delays[1]);
const data3 = fetchSimulator('https://crocoder.dev/data3', delays[2]);

Promise.race([data1, data2, data3])
  .then((response) => {
    console.log('This is the fastest response:', response);
  });

```
Each Promise is set to resolve after a different duration. 

**`Promise.race()`** is used to wait for only the first Promise to resolve. Once the first Promise resolves, its result is processed. 

This demonstrates how **`Promise.race()`** can be used to handle scenarios where only the first completion (or error) in a group of asynchronous operations is of interest.

</ListToggle>


export default (props) => <BlogLayout meta={meta} {...props}>{props.children}</BlogLayout>;
